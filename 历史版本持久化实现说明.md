# 历史版本持久化实现说明

## 问题描述

刷新页面后，当前所处的历史版本位置丢失，导致：
1. 历史记录列表中"当前"标记消失
2. 无法知道当前处于哪个版本
3. 撤销/重做功能异常

## 解决方案

使用 **KV 存储**持久化当前历史版本，以文章 ID 为键，历史记录 ID 为值。

## 实现细节

### 1. 数据库升级（Version 5）

**文件**：`src/shared/db/index.ts`

- 升级数据库版本到 5
- 新增 `kvStore` 表，用于存储键值对
- 键格式：`current_history_{articleId}`
- 值：当前历史记录的 ID

```typescript
// Version 5: 添加 KV 存储表
if (oldVersion < 5) {
  if (!db.objectStoreNames.contains('kvStore')) {
    db.createObjectStore('kvStore', { keyPath: 'key' })
  }
}
```

### 2. 类型定义

**文件**：`src/shared/types/index.ts`

新增 `KVRecord` 类型和 `AppDB` 接口扩展：

```typescript
/** KV 存储记录类型 */
export interface KVRecord {
  /** 键名 */
  key: string
  /** 值（JSON 字符串或普通字符串） */
  value: string
}

// AppDB 接口扩展
kvStore: {
  key: string
  value: KVRecord
}
```

### 3. KV 数据库操作类

**文件**：`src/shared/db/index.ts`

新增 `kvdb` 操作类，提供：
- `set(key, value)` - 设置键值对
- `get(key)` - 获取键值
- `delete(key)` - 删除键值对
- `setCurrentHistoryId(articleId, historyId)` - 设置当前历史版本 ID
- `getCurrentHistoryId(articleId)` - 获取当前历史版本 ID
- `deleteCurrentHistoryId(articleId)` - 删除当前历史版本 ID

### 4. History Store 更新

**文件**：`src/domains/editor/stores/history.store.ts`

#### 4.1 loadHistories 方法

- 新增 `resetIndex` 参数（默认 `true`）
- `resetIndex = true`：从数据库加载当前版本 ID，恢复索引位置
- `resetIndex = false`：保持内存中的索引位置
- 自动进行边界检查

```typescript
async loadHistories(articleId: string, resetIndex: boolean = true) {
  const histories = await historydb.getArticleHistories(articleId)
  this.currentHistories = histories

  let currentIndex = -1

  if (resetIndex) {
    // 从数据库加载当前历史版本 ID
    const currentHistoryId = await kvdb.getCurrentHistoryId(articleId)
    if (currentHistoryId) {
      const index = histories.findIndex(h => h.id === currentHistoryId)
      if (index !== -1) {
        currentIndex = index
      }
    }
  } else {
    // 保持内存中的状态
    const existingState = this.articleStates.get(articleId)
    currentIndex = existingState ? existingState.currentIndex : -1
  }

  // 边界检查
  if (currentIndex >= histories.length) {
    currentIndex = -1
  }

  this.articleStates.set(articleId, {
    currentIndex,
    totalCount: histories.length
  })
}
```

#### 4.2 修改 saveNewVersion 方法

**文件**：`src/domains/editor/services/history.service.ts`

让它返回新创建的历史记录 ID：

```typescript
export async function saveNewVersion(
  articleId: string,
  oldContent: string,
  newContent: string
): Promise<string> {  // 修改返回类型
  // ...
  const newRecord: ArticleHistoryRecord = {
    id: uid(),
    // ...
  }

  await historydb.createHistory(newRecord)
  await historydb.clearOldTopSnapshot(articleId)

  return newRecord.id  // 返回新记录 ID
}
```

#### 4.3 更新 resetIndex 方法

**文件**：`src/domains/editor/stores/history.store.ts`

支持接收新栈顶 ID 参数，用于同步更新 KV 存储：

```typescript
async resetIndex(newTopHistoryId?: string) {
  if (!this.currentArticleId) return
  const state = this.articleStates.get(this.currentArticleId)
  if (state) {
    state.currentIndex = -1

    // 如果提供了新栈顶 ID，更新 KV 存储
    if (newTopHistoryId) {
      await kvdb.setCurrentHistoryId(this.currentArticleId, newTopHistoryId)
      console.log(`[重置] 已更新 KV 存储的栈顶 ID: ${newTopHistoryId}`)
    } else {
      // 否则删除 KV 记录
      await kvdb.deleteCurrentHistoryId(this.currentArticleId)
    }
  }
}
```

这样保证了：
- **保存新版本时**：传入 `newTopHistoryId`，KV 存储更新为最新栈顶 ID
- **删除所有历史时**：不传参数，KV 存储被清除

#### 4.4 新增 saveCurrentVersion 方法

**文件**：`src/domains/editor/stores/history.store.ts`

在撤销/重做/回退操作时调用，持久化当前版本：

```typescript
async saveCurrentVersion() {
  if (!this.currentArticleId) return

  const state = this.articleStates.get(this.currentArticleId)
  if (!state) return

  // 如果在最新版本，删除 KV 记录
  if (state.currentIndex === -1) {
    await kvdb.deleteCurrentHistoryId(this.currentArticleId)
    return
  }

  // 获取当前版本的历史 ID 并保存
  const currentHistory = this.currentHistories[state.currentIndex]
  if (currentHistory) {
    await kvdb.setCurrentHistoryId(this.currentArticleId, currentHistory.id)
  }
}
```

#### 4.5 更新相关方法

在以下方法中调用 `saveCurrentVersion()`：
- `undo()` - 撤销后保存
- `redo()` - 重做后保存
- `revertToHistory()` - 回退后保存

注意：`resetIndex()` 不再调用 `saveCurrentVersion()`，而是直接接收 `newTopHistoryId` 参数来更新 KV 存储。

### 5. EditPage 更新

**文件**：`src/pages/EditPage.vue`

1. **接收 saveNewVersion 返回的 ID**：
```typescript
const newTopHistoryId = await saveNewVersion(selectedArticleStore.v.id, oldText, cleanedContent)
```

2. **传递给 resetIndex**：
```typescript
await historyStore.resetIndex(newTopHistoryId)
```

这样确保了保存新版本后，KV 存储中的当前版本 ID 会同步更新为新栈顶的 ID。

## 工作流程

### 初始加载文章

```
1. 用户打开文章
2. historyStore.initArticle(articleId)
3. loadHistories(articleId, true)
   - 从数据库获取历史记录列表
   - 从 KV 存储获取当前版本 ID
   - 根据 ID 查找索引位置
   - 恢复 currentIndex
```

### 撤销/重做操作

```
1. 用户点击撤销/重做
2. historyStore.undo/redo()
   - 计算目标索引
   - 重建内容
   - 更新 currentIndex
   - 调用 saveCurrentVersion()
     - 保存当前历史记录 ID 到 KV 存储
```

### 回退到历史版本

```
1. 用户点击历史版本
2. historyStore.revertToHistory(historyId)
   - 查找目标索引
   - 重建内容
   - 更新 currentIndex
   - 调用 saveCurrentVersion()
     - 保存历史记录 ID 到 KV 存储
```

### 保存新版本

```
1. 用户编辑内容并保存
2. saveNewVersion()
   - 创建新的栈顶记录
   - 返回新记录的 ID
3. historyStore.resetIndex(newTopHistoryId)
   - 设置 currentIndex = -1
   - 将新栈顶 ID 写入 KV 存储（重要！）
   - 确保下次刷新时恢复到最新版本
```

### 刷新页面

```
1. 页面刷新
2. 用户打开文章
3. loadHistories(articleId, true)
   - 从 KV 存储恢复当前版本 ID
   - 查找对应的索引
   - 恢复 currentIndex
4. UI 正确显示"当前"标记
```

## 数据一致性

### 边界情况处理

1. **历史记录被删除**
   - 如果 KV 存储中的历史 ID 在记录列表中不存在
   - 自动重置 `currentIndex = -1`

2. **索引超出范围**
   - 如果 `currentIndex >= histories.length`
   - 自动重置 `currentIndex = -1`

3. **在最新版本**
   - `currentIndex = -1` 时，删除 KV 记录
   - 避免不必要的存储空间占用

### 性能优化

1. **KV 存储轻量级**
   - 只存储 ID，不存储完整内容
   - 每篇文章只有一条 KV 记录

2. **按需加载**
   - 只在 `loadHistories(resetIndex=true)` 时读取
   - 刷新列表时不重复读取

3. **异步操作**
   - 所有持久化操作都是异步的
   - 不阻塞 UI 交互

## 测试建议

1. **基础功能测试**
   - 打开文章，撤销几次，刷新页面，检查"当前"标记是否正确

2. **边界测试**
   - 删除历史记录后刷新，检查是否正确重置
   - 在历史版本位置编辑并保存，检查是否重置到最新

3. **多文章测试**
   - 切换不同文章，检查各自的当前版本是否独立维护

4. **性能测试**
   - 在有大量历史记录的文章中测试，检查加载速度

## 总结

通过 KV 存储持久化当前历史版本，实现了：
- ✅ 刷新后保持当前版本位置
- ✅ "当前"标记正确显示
- ✅ 撤销/重做功能完全正常
- ✅ 数据一致性保障
- ✅ 性能优化

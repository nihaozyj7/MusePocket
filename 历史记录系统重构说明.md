# 历史记录系统重构说明

## 设计理念

实现了真正的**撤销/重做指针模型**，类似于 Git 的工作方式：

### 核心概念

1. **栈顶始终是最新记录**
   - 栈顶（索引 0）保存完整快照（fullContent）
   - 其他记录只保存 diff

2. **currentIndex 指针**
   - `-1` 表示当前在最新版本（栈顶）
   - `0` 表示在第 1 个历史版本
   - `1` 表示在第 2 个历史版本
   - 以此类推...

3. **回退操作不创建新版本**
   - 回退只移动 currentIndex 指针
   - 栈顶不变，历史记录不变

4. **在历史版本位置保存时舍弃后续记录**
   - 如果 currentIndex = 2（在第 3 个历史版本）
   - 此时保存新内容，会删除索引 0 和 1 的记录（最新的 2 条）
   - 然后将新内容作为新的栈顶

## 关键修复

### 1. 空字符串判断 Bug ⚠️

**问题**：
```typescript
if (!topHistory.fullContent) {  // ❌ 错误！空字符串 "" 会被判断为 false
  console.error('栈顶快照丢失')
  return null
}
```

当用户删除所有内容后保存，`fullContent` 是 `""`（空字符串），但不是 `null`。
空字符串在 JavaScript 中是 falsy 值，导致误判为"快照丢失"。

**修复**：
```typescript
if (topHistory.fullContent === null) {  // ✅ 正确！严格检查 null
  console.error('栈顶快照丢失')
  return null
}
```

### 2. 回退操作逻辑

**之前（错误）**：
- 回退时创建新版本记录
- 导致历史记录无限增长
- 无法真正实现撤销/重做

**现在（正确）**：
```typescript
async revertToHistory(historyId: string): Promise<string | null> {
  // 1. 查找目标索引
  const targetIndex = this.currentHistories.findIndex(h => h.id === historyId)

  // 2. 重建内容
  const content = await reconstructContentAtIndex(this.currentArticleId, targetIndex)

  // 3. 只移动指针，不创建新版本
  state.currentIndex = targetIndex

  return content
}
```

### 3. 保存时舍弃逻辑

**实现**：
```typescript
async function saveArticle(text: string, oldText?: string, skipHistory: boolean = false) {
  if (!skipHistory && oldText !== undefined && oldText !== cleanedContent) {
    // 检查当前索引
    const currentIndex = historyStore.getCurrentIndex()
    console.log(`[保存] 当前索引: ${currentIndex}`)

    // 如果在非栈顶位置保存，先舍弃后续记录
    if (currentIndex > 0) {
      console.log(`[保存] 将舍弃索引 0 到 ${currentIndex - 1} 的 ${currentIndex} 条记录`)
      await historyStore.discardRecordsAfterIndex(currentIndex)
    }

    // 保存新版本
    await saveNewVersion(selectedArticleStore.v.id, oldText, cleanedContent)

    // 刷新并重置到栈顶
    await historyStore.refreshHistories()
    historyStore.resetIndex()
  }
}
```

## 操作流程示例

### 场景 1：正常编辑保存

```
初始状态：
  栈顶 [V3] currentIndex=-1 ← 当前位置
       [V2]
       [V1]
       [V0]

保存后：
  栈顶 [V4] currentIndex=-1 ← 新位置
       [V3]
       [V2]
       [V1]
       [V0]
```

### 场景 2：撤销操作

```
初始状态：
  栈顶 [V3] currentIndex=-1 ← 当前
       [V2]
       [V1]
       [V0]

按 Ctrl+Z 撤销：
  栈顶 [V3]
       [V2] currentIndex=0 ← 移动到这里
       [V1]
       [V0]

再按 Ctrl+Z：
  栈顶 [V3]
       [V2]
       [V1] currentIndex=1 ← 移动到这里
       [V0]
```

### 场景 3：重做操作

```
当前状态：
  栈顶 [V3]
       [V2]
       [V1] currentIndex=1 ← 当前位置
       [V0]

按 Ctrl+Y 重做：
  栈顶 [V3]
       [V2] currentIndex=0 ← 向前移动
       [V1]
       [V0]

再按 Ctrl+Y：
  栈顶 [V3] currentIndex=-1 ← 回到栈顶
       [V2]
       [V1]
       [V0]
```

### 场景 4：在历史版本位置保存

```
初始状态：
  栈顶 [V3]
       [V2]
       [V1] currentIndex=1 ← 当前位置
       [V0]

用户修改内容并保存：

步骤 1 - 舍弃后续记录：
       [V1] currentIndex=1
       [V0]

步骤 2 - 保存新版本：
  栈顶 [V4 - 新内容] currentIndex=-1
       [V1]
       [V0]
```

## 数据库结构

### ArticleHistoryRecord

```typescript
interface ArticleHistoryRecord {
  id: string                    // 记录 ID
  articleId: string             // 所属文章 ID
  diffFromPrev: string | null   // 从上一版本到本版本的 diff（JSON）
  fullContent: string | null    // 完整快照（只有栈顶有值）
  createdTime: number           // 创建时间
  modifiedTime: number          // 修改时间
  deletedTime: number           // 删除时间
}
```

### 存储策略

- **栈顶（最新）**：
  - `fullContent`: 完整内容（可以是空字符串 `""`）
  - `diffFromPrev`: 相对于上一版本的 diff

- **非栈顶**：
  - `fullContent`: `null`（节省空间）
  - `diffFromPrev`: 相对于上一版本的 diff

## 新增的 Store 方法

### `getCurrentIndex()`
获取当前索引位置

### `resetIndex()`
重置索引到栈顶（-1）

### `discardRecordsAfterIndex(currentIndex: number)`
舍弃当前索引到栈顶之间的记录

**示例**：
```typescript
// currentIndex = 2，总共有 5 条记录
// 索引：0, 1, 2, 3, 4
// 舍弃：0, 1（最新的 2 条）
await discardRecordsAfterIndex(2)
```

## 测试建议

### 1. 基础测试

1. **正常编辑保存**
   - 输入文字 → 等待保存 → 检查历史记录增加

2. **撤销测试**
   - 保存几次 → 按 Ctrl+Z → 内容应该回退
   - 检查控制台：`[回退] currentIndex 设置为: X`

3. **重做测试**
   - 撤销后 → 按 Ctrl+Y → 内容应该前进
   - 检查控制台：`[回退] currentIndex 设置为: Y`

4. **空内容测试** ⚠️ **重要**
   - 输入文字 → 保存
   - 删除所有文字 → 保存
   - 按 Ctrl+Z → 应该能恢复文字
   - **不应该出现"栈顶快照丢失"错误**

### 2. 高级测试

1. **历史版本回退**
   - 保存 5 次
   - 打开历史侧边栏
   - 点击第 3 个版本 → 内容应该变为第 3 版
   - 检查：currentIndex = 2

2. **在历史版本位置保存**
   - 回退到历史版本（如 V2）
   - 修改内容
   - 等待保存
   - 检查：V2 之后的记录（V3, V4...）应该被删除

3. **舍弃记录验证**
   - 保存 4 次（V0, V1, V2, V3）
   - 撤销 2 次（currentIndex = 1，在 V1 位置）
   - 修改并保存
   - 检查：V2 和 V3 应该被删除，新版本成为栈顶

## 控制台日志说明

### 保存版本

```
[保存] 当前索引: 1, 内容已变化，准备保存历史
[保存] 检测到在索引 1 位置保存，将舍弃该索引之前的 1 条记录
[舍弃记录] 开始舍弃索引 0 到 0 的记录
[舍弃记录] 已删除: xxx
[舍弃记录] 共删除 1 条记录
[保存版本] 文章ID: xxx, 旧内容长度: 10, 新内容长度: 15
[保存版本] 新记录已创建: xxx
[保存版本] 清除旧快照: true
[重置] currentIndex 设置为: -1
```

### 重建内容

```
[重建内容] 文章ID: xxx, 目标索引: 2, 总记录数: 5
[重建内容] 栈顶记录ID: xxx, 有快照: true, 快照长度: 123
[重建内容] 应用第 1 条 diff，当前内容长度: 100
[重建内容] 应用第 2 条 diff，当前内容长度: 80
[重建内容] 完成，最终内容长度: 80
```

## 注意事项

1. **空字符串 vs null**
   - `fullContent = ""` 是有效的快照（用户删除了所有内容）
   - `fullContent = null` 表示没有快照
   - 必须使用 `=== null` 严格判断

2. **索引方向**
   - 索引 0 是最新的历史版本（不是栈顶）
   - 索引 1 是第二新的历史版本
   - currentIndex = -1 表示在栈顶（当前最新状态）

3. **舍弃逻辑**
   - 舍弃的是"更新的"记录，不是"更旧的"
   - 如果 currentIndex = 2，舍弃索引 0 和 1
   - 这样新保存的内容才能成为栈顶

4. **数据库一致性**
   - 舍弃记录后必须刷新历史列表
   - 保存后必须重置 currentIndex 到 -1
   - 确保指针和数据库状态同步

## 修改的文件

1. ✅ `src/domains/editor/services/history.service.ts`
   - 修复空字符串判断 Bug
   - 添加详细日志

2. ✅ `src/domains/editor/stores/history.store.ts`
   - 添加 `getCurrentIndex()`
   - 添加 `resetIndex()`
   - 添加 `discardRecordsAfterIndex()`
   - 修改 `revertToHistory()` 只移动指针

3. ✅ `src/pages/EditPage.vue`
   - 修改 `saveArticle()` 添加舍弃逻辑
   - 修改 `handleRestoreFromHistory()` 不创建新版本

4. ✅ `src/shared/db/index.ts`
   - 已有 `deleteHistory()` 方法可用

